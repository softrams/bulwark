import { UserRequest } from '../interfaces/user-request.interface';
import { Response } from 'express';
import { Assessment } from '../entity/Assessment';
import { validate } from 'class-validator';
import { Vulnerability } from '../entity/Vulnerability';
import { File } from '../entity/File';
import { ProblemLocation } from '../entity/ProblemLocation';
import { Resource } from '../entity/Resource';
import { exportToJiraIssue } from '../utilities/jira.utility';
import { JiraInit } from '../interfaces/jira/jira-init.interface';
import { Jira } from '../entity/Jira';
import {
  hasAssetReadAccess,
  hasAssetWriteAccess,
} from '../utilities/role.utility';
import { getConnection } from 'typeorm';
const fileUploadController = require('../routes/file-upload.controller');

/**
 * @description get vulnerability by ID
 * @param {UserRequest} req
 * @param {Response} res contains JSON object with the organization data
 * @returns vulnerability data
 */
export const getVulnById = async (req: UserRequest, res: Response) => {
  if (!req.params.vulnId) {
    return res.status(400).send('Invalid Vulnerability UserRequest');
  }
  if (isNaN(+req.params.vulnId)) {
    return res.status(400).send('Invalid Vulnerability ID');
  }
  // TODO: Utilize createQueryBuilder to only return screenshot IDs and not the full object
  const vuln = await getConnection().getRepository(Vulnerability).findOne({
    where: { id: +req.params.vulnId },
    relations: ['screenshots', 'problemLocations', 'resources', 'assessment'],
  });
  const assessment = await getConnection()
    .getRepository(Assessment)
    .createQueryBuilder('assessment')
    .leftJoinAndSelect('assessment.asset', 'asset')
    .leftJoinAndSelect('asset.organization', 'organization')
    .where('assessment.id = :assessmentId', {
      assessmentId: vuln.assessment.id,
    })
    .select(['assessment', 'asset', 'organization'])
    .getOne();
  const hasReadAccess = await hasAssetReadAccess(req, assessment.asset.id);
  if (!hasReadAccess) {
    return res.status(404).json('Vulnerability not found');
  }
  const hasAccess = await hasAssetWriteAccess(req, assessment.asset.id);
  const jira = await getConnection()
    .getRepository(Jira)
    .findOne({ where: { asset: assessment.asset } });
  const jiraHost = jira ? jira.host : null;
  if (!vuln) {
    return res.status(404).send('Vulnerability does not exist.');
  }
  return res
    .status(200)
    .json({ vulnerability: vuln, jiraHost, readOnly: !hasAccess });
};
/**
 * @description Delete vulnerability by ID
 * @param {UserRequest} req vulnID is required
 * @param {Response} res contains JSON object with the success/fail
 * @returns success/error message
 */
export const deleteVulnById = async (req: UserRequest, res: Response) => {
  if (!req.params.vulnId) {
    return res.status(400).send('Invalid vulnerability UserRequest');
  }
  if (isNaN(+req.params.vulnId)) {
    return res.status(400).send('Invalid vulnerability ID');
  }
  const vuln = await getConnection()
    .getRepository(Vulnerability)
    .findOne({ where: { id: +req.params.vulnId }, relations: ['assessment'] });
  if (!vuln) {
    return res.status(404).send('Vulnerability does not exist.');
  } else {
    const assessment = await getConnection()
        .getRepository(Assessment)
        .findOne({ where: { id: req.body.assessment }, relations: ['asset'] });
    const hasAccess = await hasAssetWriteAccess(req, assessment.asset.id);
    if (!hasAccess) {
      return res.status(403).json('Authorization is required');
    }
    await getConnection().getRepository(Vulnerability).delete(vuln);
    return res
      .status(200)
      .json(`Vulnerability #${vuln.id}: "${vuln.name}" successfully deleted`);
  }
};
/**
 * @description Update vulnerability by ID
 * @param {UserRequest} req
 * @param {Response} res
 * @returns success/error message
 * // TODO: Break apart this function into smaller functions.  Also make common as create is almost the same.
 */
export const patchVulnById = async (req: UserRequest, res: Response) => {
  req = await fileUploadController.uploadFileArray(req, res);
  if (isNaN(+req.body.assessment) || !req.body.assessment) {
    return res.status(400).json('Invalid Assessment ID');
  }
  const assessment = await getConnection()
    .getRepository(Assessment)
    .findOne({ where: { id: req.body.assessment }, relations: ['asset'] });
  if (!assessment) {
    return res.status(404).json('Assessment does not exist');
  }
  const hasAccess = await hasAssetWriteAccess(req, assessment.asset.id);
  if (!hasAccess) {
    return res.status(403).json('Authorization is required');
  }
  if (isNaN(+req.params.vulnId)) {
    return res.status(400).json('Vulnerability ID is invalid');
  }
  const vulnerability = await getConnection()
    .getRepository(Vulnerability)
    .findOne({ where: { id: +req.params.vulnId } });
  if (!vulnerability) {
    return res.status(404).json('Vulnerability does not exist');
  }
  const callback = (resStatus: number, message: any) => {
    res.status(resStatus).send(message);
  };
  vulnerability.id = +req.params.vulnId;
  vulnerability.impact = req.body.impact;
  vulnerability.likelihood = req.body.likelihood;
  vulnerability.risk = req.body.risk;
  vulnerability.status = req.body.status;
  vulnerability.description = req.body.description;
  vulnerability.remediation = req.body.remediation;
  vulnerability.jiraId = req.body.jiraId;
  vulnerability.cvssScore = req.body.cvssScore;
  vulnerability.cvssUrl = req.body.cvssUrl;
  vulnerability.detailedInfo = req.body.detailedInfo;
  vulnerability.assessment = assessment;
  vulnerability.name = req.body.name;
  vulnerability.systemic = req.body.systemic;
  const errors = await validate(vulnerability);
  if (errors.length > 0) {
    return res.status(400).send('Vulnerability form validation failed');
  } else {
    await getConnection().getRepository(Vulnerability).save(vulnerability);
    // Remove deleted files
    if (req.body.screenshotsToDelete) {
      const existingScreenshots = await getConnection()
        .getRepository(File)
        .find({ where: { vulnerability: { id: vulnerability.id } } });
      const existingScreenshotIds = existingScreenshots.map(
        (screenshot) => screenshot.id
      );
      let screenshotsToDelete = JSON.parse(req.body.screenshotsToDelete);
      // We only want to remove the files associated to the vulnerability
      screenshotsToDelete = existingScreenshotIds.filter((value) =>
        screenshotsToDelete.includes(value)
      );
      for (const screenshotId of screenshotsToDelete) {
        getConnection().getRepository(File).delete(screenshotId);
      }
    }
    saveScreenshots(req.files, vulnerability, callback);
    // Remove deleted problem locations
    if (req.body.problemLocations.length) {
      const clientProdLocs = JSON.parse(req.body.problemLocations);
      const clientProdLocsIds = clientProdLocs.map((value) => value.id);
      const existingProbLocs = await getConnection()
        .getRepository(ProblemLocation)
        .find({ where: { vulnerability: { id: vulnerability.id } } });
      const existingProbLocIds = existingProbLocs.map((probLoc) => probLoc.id);
      const prodLocsToDelete = existingProbLocIds.filter(
        (value) => !clientProdLocsIds.includes(value)
      );
      for (const probLoc of prodLocsToDelete) {
        getConnection().getRepository(ProblemLocation).delete(probLoc);
      }
      saveProblemLocations(clientProdLocs, vulnerability, callback);
    }
    // Remove deleted resources
    if (req.body.resources.length) {
      const clientResources = JSON.parse(req.body.resources);
      const clientResourceIds = clientResources.map((value) => value.id);
      const existingResources = await getConnection()
        .getRepository(Resource)
        .find({ where: { vulnerability: { id: vulnerability.id } } });
      const existingResourceIds = existingResources.map(
        (resource) => resource.id
      );
      const resourcesToDelete = existingResourceIds.filter(
        (value) => !clientResourceIds.includes(value)
      );
      for (const resource of resourcesToDelete) {
        getConnection().getRepository(Resource).delete(resource);
      }
      saveResources(clientResources, vulnerability, callback);
    }
    return res.status(200).json('Vulnerability patched successfully');
  }
};
/**
 * @description Create vulnerability
 * @param {UserRequest} req
 * @param {Response} res
 * @returns success/error message
 */
export const createVuln = async (req: UserRequest, res: Response) => {
  req = await fileUploadController.uploadFileArray(req, res);
  if (isNaN(+req.body.assessment) || !req.body.assessment) {
    return res.status(400).json('Invalid Assessment ID');
  }
  const assessment = await getConnection()
    .getRepository(Assessment)
    .findOne({ where: { id: req.body.assessment }, relations: ['asset'] });
  if (!assessment) {
    return res.status(404).json('Assessment does not exist');
  }
  const hasAccess = await hasAssetWriteAccess(req, assessment.asset.id);
  if (!hasAccess) {
    return res.status(403).json('Authorization is required');
  }
  const callback = (resStatus: number, message: any) => {
    res.status(resStatus).send(message);
  };
  const vulnerability = new Vulnerability();
  vulnerability.impact = req.body.impact;
  vulnerability.likelihood = req.body.likelihood;
  vulnerability.risk = req.body.risk;
  vulnerability.status = req.body.status;
  vulnerability.description = req.body.description;
  vulnerability.remediation = req.body.remediation;
  vulnerability.jiraId = req.body.jiraId;
  vulnerability.cvssScore = req.body.cvssScore;
  vulnerability.cvssUrl = req.body.cvssUrl;
  vulnerability.detailedInfo = req.body.detailedInfo;
  vulnerability.assessment = assessment;
  vulnerability.name = req.body.name;
  vulnerability.systemic = req.body.systemic;
  const errors = await validate(vulnerability);
  if (errors.length > 0) {
    return res.status(400).send('Vulnerability form validation failed');
  } else {
    await getConnection().getRepository(Vulnerability).save(vulnerability);
    saveScreenshots(req.files, vulnerability, callback);
    const problemLocations = JSON.parse(req.body.problemLocations);
    saveProblemLocations(problemLocations, vulnerability, callback);
    const resources = JSON.parse(req.body.resources);
    saveResources(resources, vulnerability, callback);
    res.status(200).json('Vulnerability saved successfully');
  }
};
/**
 * @description Save screenshots to vulnerability
 * @param {UserRequest} req
 * @param {Response} res
 * @param {Vulnerability} vulnerability
 * @returns saved file or error message
 */
export const saveScreenshots = async (
  files: File[],
  vulnerability: Vulnerability,
  callback
) => {
  for (const screenshot of files) {
    let file = new File();
    file = screenshot;
    file.vulnerability = vulnerability;
    const fileErrors = await validate(file);
    if (fileErrors.length > 0) {
      return callback(400, JSON.stringify('File validation failed'));
    } else {
      await getConnection().getRepository(File).save(file);
    }
  }
};
/**
 * @description Save problem locations to vulnerability
 * @param {UserRequest} req
 * @param {Response} res
 * @param {Vulnerability} vulnerability
 * @returns saved problem locations or error message
 */
export const saveProblemLocations = async (
  problemLocations: ProblemLocation[],
  vulnerability: Vulnerability,
  callback
) => {
  for (const probLoc of problemLocations) {
    if (probLoc && probLoc.location && probLoc.target) {
      let problemLocation = new ProblemLocation();
      problemLocation = probLoc;
      problemLocation.vulnerability = vulnerability;
      const plErrors = await validate(problemLocation);
      if (plErrors.length > 0) {
        return callback(
          400,
          JSON.stringify('Problem Location validation failed')
        );
      } else {
        await getConnection()
          .getRepository(ProblemLocation)
          .save(problemLocation);
      }
    } else {
      return callback(400, JSON.stringify('Invalid Problem Location'));
    }
  }
};
/**
 * @description Save resources to vulnerability
 * @param {UserRequest} req
 * @param {Response} res
 * @param {Vulnerability} vulnerability
 * @returns saved resources or error message
 */
export const saveResources = async (
  resources: Resource[],
  vulnerability: Vulnerability,
  callback
) => {
  for (const resource of resources) {
    if (resource.description && resource.url) {
      let newResource = new Resource();
      newResource = resource;
      newResource.vulnerability = vulnerability;
      const nrErrors = await validate(newResource);
      if (nrErrors.length > 0) {
        return callback(
          400,
          JSON.stringify('Resource Location validation failed')
        );
      } else {
        await getConnection().getRepository(Resource).save(newResource);
      }
    } else {
      return callback(400, JSON.stringify('Resource Location Invalid'));
    }
  }
};
/**
 * @description Generate JIRA Ticket from Vuln
 * @param {UserRequest} req
 * @param {Response} res
 * @param {Vulnerability} vulnerability
 * @returns JIRA return ID?
 */
export const exportToJira = async (req: UserRequest, res: Response) => {
  if (!req.params.vulnId) {
    return res.status(400).json('Invalid Vulnerability ID');
  }
  if (isNaN(+req.params.vulnId)) {
    return res.status(400).json('Invalid Vulnerability ID');
  }
  const vuln = await getConnection()
    .getRepository(Vulnerability)
    .findOne({
      where: { id: +req.params.vulnId },
      relations: ['screenshots', 'resources', 'problemLocations', 'assessment'],
    });
  const assessment = await getConnection()
    .getRepository(Assessment)
    .findOne({ where: { id: vuln.assessment.id }, relations: ['asset'] });
  const hasAccess = await hasAssetWriteAccess(req, assessment.asset.id);
  if (!hasAccess) {
    return res.status(403).json('Authorization is required');
  }
  const jira = await getConnection()
    .getRepository(Jira)
    .findOne({ where: { asset: assessment.asset } });

  if (!assessment.jiraId) {
    return res
      .status(400)
      .json(
        'Unable to create JIRA ticket.  Assessment requires an associated Jira ticket.'
      );
  }
  if (!jira) {
    return res
      .status(400)
      .json(
        'Unable to create JIRA ticket.  Please provide JIRA credentials to the parent Asset.'
      );
  }
  const jiraInit: JiraInit = {
    apiKey: jira.apiKey,
    host: jira.host,
    username: jira.username,
  };
  try {
    const result = await exportToJiraIssue(vuln, jiraInit);
    vuln.jiraId = `https://${jiraInit.host}/browse/${result.key}`;
    await getConnection().getRepository(Vulnerability).save(vuln);
    return res.status(200).json(`${result.message}`);
  } catch (err) {
    return res.status(404).json(err);
  }
};
