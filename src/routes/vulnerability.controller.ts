import { UserRequest } from '../interfaces/user-request.interface';
import { Response } from 'express';
import { AppDataSource } from '../data-source';
import { Assessment } from '../entity/Assessment';
import { validate } from 'class-validator';
import { Vulnerability } from '../entity/Vulnerability';
import { File } from '../entity/File';
import { ProblemLocation } from '../entity/ProblemLocation';
import { Resource } from '../entity/Resource';
import { exportToJiraIssue } from '../utilities/jira.utility';
import { JiraInit } from '../interfaces/jira/jira-init.interface';
import { Jira } from '../entity/Jira';
import {
  hasAssetReadAccess,
  hasAssetWriteAccess,
} from '../utilities/role.utility';
const fileUploadController = require('../routes/file-upload.controller');

/**
 * @description get vulnerability by ID
 * @param {UserRequest} req
 * @param {Response} res contains JSON object with the organization data
 * @returns vulnerability data
 */
export const getVulnById = async (req: UserRequest, res: Response) => {
  try {
    if (!req.params.vulnId) {
      return res.status(400).send('Invalid Vulnerability Request');
    }
    if (isNaN(+req.params.vulnId)) {
      return res.status(400).send('Invalid Vulnerability ID');
    }
    
    const vulnerabilityRepository = AppDataSource.getRepository(Vulnerability);
    const assessmentRepository = AppDataSource.getRepository(Assessment);
    const jiraRepository = AppDataSource.getRepository(Jira);
    
    // Get vulnerability with relations
    const vuln = await vulnerabilityRepository.findOne({
      where: { id: +req.params.vulnId },
      relations: ['screenshots', 'problemLocations', 'resources', 'assessment']
    });
    
    if (!vuln) {
      return res.status(404).send('Vulnerability does not exist.');
    }
    
    const assessment = await assessmentRepository.findOne({
      where: { id: vuln.assessment.id },
      relations: ['asset', 'asset.organization']
    });
    
    const hasReadAccess = await hasAssetReadAccess(req, assessment.asset.id);
    if (!hasReadAccess) {
      return res.status(404).json('Vulnerability not found');
    }
    
    const hasAccess = await hasAssetWriteAccess(req, assessment.asset.id);
    
    const jira = await jiraRepository.findOne({
      where: { asset: { id: assessment.asset.id } }
    });
    
    const jiraHost = jira ? jira.host : null;
    
    return res
      .status(200)
      .json({ vulnerability: vuln, jiraHost, readOnly: !hasAccess });
  } catch (error) {
    console.error('Error fetching vulnerability:', error);
    return res.status(500).json('An error occurred while fetching the vulnerability');
  }
};

/**
 * @description Delete vulnerability by ID
 * @param {UserRequest} req vulnID is required
 * @param {Response} res contains JSON object with the success/fail
 * @returns success/error message
 */
export const deleteVulnById = async (req: UserRequest, res: Response) => {
  try {
    if (!req.params.vulnId) {
      return res.status(400).send('Invalid vulnerability request');
    }
    if (isNaN(+req.params.vulnId)) {
      return res.status(400).send('Invalid vulnerability ID');
    }
    
    const vulnerabilityRepository = AppDataSource.getRepository(Vulnerability);
    const assessmentRepository = AppDataSource.getRepository(Assessment);
    
    const vuln = await vulnerabilityRepository.findOne({
      where: { id: +req.params.vulnId },
      relations: ['assessment']
    });
    
    if (!vuln) {
      return res.status(404).send('Vulnerability does not exist.');
    }
    
    const assessment = await assessmentRepository.findOne({
      where: { id: vuln.assessment.id },
      relations: ['asset']
    });
    
    const hasAccess = await hasAssetWriteAccess(req, assessment.asset.id);
    if (!hasAccess) {
      return res.status(403).json('Authorization is required');
    }
    
    await vulnerabilityRepository.remove(vuln);
    
    return res
      .status(200)
      .json(`Vulnerability #${vuln.id}: "${vuln.name}" successfully deleted`);
  } catch (error) {
    console.error('Error deleting vulnerability:', error);
    return res.status(500).json('An error occurred while deleting the vulnerability');
  }
};

/**
 * @description Update vulnerability by ID
 * @param {UserRequest} req
 * @param {Response} res
 * @returns success/error message
 */
export const patchVulnById = async (req: UserRequest, res: Response) => {
  try {
    req = await fileUploadController.uploadFileArray(req, res);
    
    if (isNaN(+req.body.assessment) || !req.body.assessment) {
      return res.status(400).json('Invalid Assessment ID');
    }
    
    const assessmentRepository = AppDataSource.getRepository(Assessment);
    const vulnerabilityRepository = AppDataSource.getRepository(Vulnerability);
    const fileRepository = AppDataSource.getRepository(File);
    const problemLocationRepository = AppDataSource.getRepository(ProblemLocation);
    const resourceRepository = AppDataSource.getRepository(Resource);
    
    const assessment = await assessmentRepository.findOne({
      where: { id: +req.body.assessment },
      relations: ['asset']
    });
    
    if (!assessment) {
      return res.status(404).json('Assessment does not exist');
    }
    
    const hasAccess = await hasAssetWriteAccess(req, assessment.asset.id);
    if (!hasAccess) {
      return res.status(403).json('Authorization is required');
    }
    
    if (isNaN(+req.params.vulnId)) {
      return res.status(400).json('Vulnerability ID is invalid');
    }
    
    const vulnerability = await vulnerabilityRepository.findOne({
      where: { id: +req.params.vulnId }
    });
    
    if (!vulnerability) {
      return res.status(404).json('Vulnerability does not exist');
    }
    
    vulnerability.id = +req.params.vulnId;
    vulnerability.impact = req.body.impact;
    vulnerability.likelihood = req.body.likelihood;
    vulnerability.risk = req.body.risk;
    vulnerability.status = req.body.status;
    vulnerability.description = req.body.description;
    vulnerability.remediation = req.body.remediation;
    vulnerability.jiraId = req.body.jiraId;
    vulnerability.cvssScore = req.body.cvssScore;
    vulnerability.cvssUrl = req.body.cvssUrl;
    vulnerability.detailedInfo = req.body.detailedInfo;
    vulnerability.assessment = assessment;
    vulnerability.name = req.body.name;
    vulnerability.systemic = req.body.systemic;
    
    const errors = await validate(vulnerability);
    if (errors.length > 0) {
      return res.status(400).send('Vulnerability form validation failed');
    }
    
    await vulnerabilityRepository.save(vulnerability);
    
    // Remove deleted files
    if (req.body.screenshotsToDelete) {
      try {
        const existingScreenshots = await fileRepository.find({
          where: { vulnerability: { id: vulnerability.id } }
        });
        
        const existingScreenshotIds = existingScreenshots.map(
          (screenshot) => screenshot.id
        );
        
        let screenshotsToDelete = JSON.parse(req.body.screenshotsToDelete);
        // We only want to remove the files associated to the vulnerability
        screenshotsToDelete = existingScreenshotIds.filter((value) =>
          screenshotsToDelete.includes(value)
        );
        
        for (const screenshotId of screenshotsToDelete) {
          await fileRepository.delete(screenshotId);
        }
      } catch (error) {
        console.error('Error processing deleted screenshots:', error);
      }
    }
    
    // Save new screenshots
    if (req.files && req.files.length > 0) {
      await saveScreenshots(req.files, vulnerability);
    }
    
    // Process problem locations
    if (req.body.problemLocations && req.body.problemLocations.length) {
      try {
        const clientProdLocs = JSON.parse(req.body.problemLocations);
        const clientProdLocsIds = clientProdLocs.map((value) => value.id).filter(id => id);
        
        const existingProbLocs = await problemLocationRepository.find({
          where: { vulnerability: { id: vulnerability.id } }
        });
        
        const existingProbLocIds = existingProbLocs.map((probLoc) => probLoc.id);
        const prodLocsToDelete = existingProbLocIds.filter(
          (value) => !clientProdLocsIds.includes(value)
        );
        
        for (const probLoc of prodLocsToDelete) {
          await problemLocationRepository.delete(probLoc);
        }
        
        await saveProblemLocations(clientProdLocs, vulnerability);
      } catch (error) {
        console.error('Error processing problem locations:', error);
      }
    }
    
    // Process resources
    if (req.body.resources && req.body.resources.length) {
      try {
        const clientResources = JSON.parse(req.body.resources);
        const clientResourceIds = clientResources.map((value) => value.id).filter(id => id);
        
        const existingResources = await resourceRepository.find({
          where: { vulnerability: { id: vulnerability.id } }
        });
        
        const existingResourceIds = existingResources.map(
          (resource) => resource.id
        );
        
        const resourcesToDelete = existingResourceIds.filter(
          (value) => !clientResourceIds.includes(value)
        );
        
        for (const resource of resourcesToDelete) {
          await resourceRepository.delete(resource);
        }
        
        await saveResources(clientResources, vulnerability);
      } catch (error) {
        console.error('Error processing resources:', error);
      }
    }
    
    return res.status(200).json('Vulnerability patched successfully');
  } catch (error) {
    console.error('Error updating vulnerability:', error);
    return res.status(500).json('An error occurred while updating the vulnerability');
  }
};

/**
 * @description Create vulnerability
 * @param {UserRequest} req
 * @param {Response} res
 * @returns success/error message
 */
export const createVuln = async (req: UserRequest, res: Response) => {
  try {
    req = await fileUploadController.uploadFileArray(req, res);
    
    if (isNaN(+req.body.assessment) || !req.body.assessment) {
      return res.status(400).json('Invalid Assessment ID');
    }
    
    const assessmentRepository = AppDataSource.getRepository(Assessment);
    const vulnerabilityRepository = AppDataSource.getRepository(Vulnerability);
    
    const assessment = await assessmentRepository.findOne({
      where: { id: +req.body.assessment },
      relations: ['asset']
    });
    
    if (!assessment) {
      return res.status(404).json('Assessment does not exist');
    }
    
    const hasAccess = await hasAssetWriteAccess(req, assessment.asset.id);
    if (!hasAccess) {
      return res.status(403).json('Authorization is required');
    }
    
    const vulnerability = new Vulnerability();
    vulnerability.impact = req.body.impact;
    vulnerability.likelihood = req.body.likelihood;
    vulnerability.risk = req.body.risk;
    vulnerability.status = req.body.status;
    vulnerability.description = req.body.description;
    vulnerability.remediation = req.body.remediation;
    vulnerability.jiraId = req.body.jiraId || '';
    vulnerability.cvssScore = req.body.cvssScore;
    vulnerability.cvssUrl = req.body.cvssUrl;
    vulnerability.detailedInfo = req.body.detailedInfo;
    vulnerability.assessment = assessment;
    vulnerability.name = req.body.name;
    vulnerability.systemic = req.body.systemic;
    
    const errors = await validate(vulnerability);
    if (errors.length > 0) {
      console.error('Validation errors:', errors);
      return res.status(400).send('Vulnerability form validation failed');
    }
    
    const savedVulnerability = await vulnerabilityRepository.save(vulnerability);
    
    // Save screenshots
    if (req.files && req.files.length > 0) {
      await saveScreenshots(req.files, savedVulnerability);
    }
    
    // Save problem locations
    if (req.body.problemLocations) {
      try {
        const problemLocations = JSON.parse(req.body.problemLocations);
        await saveProblemLocations(problemLocations, savedVulnerability);
      } catch (error) {
        console.error('Error saving problem locations:', error);
      }
    }
    
    // Save resources
    if (req.body.resources) {
      try {
        const resources = JSON.parse(req.body.resources);
        await saveResources(resources, savedVulnerability);
      } catch (error) {
        console.error('Error saving resources:', error);
      }
    }
    
    return res.status(200).json('Vulnerability saved successfully');
  } catch (error) {
    console.error('Error creating vulnerability:', error);
    return res.status(500).json('An error occurred while creating the vulnerability');
  }
};

/**
 * @description Save screenshots to vulnerability
 * @param {File[]} files
 * @param {Vulnerability} vulnerability
 */
export const saveScreenshots = async (files: File[], vulnerability: Vulnerability) => {
  const fileRepository = AppDataSource.getRepository(File);
  
  for (const screenshot of files) {
    try {
      let file = new File();
      file = screenshot;
      file.vulnerability = vulnerability;
      
      const fileErrors = await validate(file);
      if (fileErrors.length > 0) {
        console.error('File validation failed:', fileErrors);
        continue;
      }
      
      await fileRepository.save(file);
    } catch (error) {
      console.error('Error saving screenshot:', error);
    }
  }
};

/**
 * @description Save problem locations to vulnerability
 * @param {ProblemLocation[]} problemLocations
 * @param {Vulnerability} vulnerability
 */
export const saveProblemLocations = async (problemLocations: ProblemLocation[], vulnerability: Vulnerability) => {
  const problemLocationRepository = AppDataSource.getRepository(ProblemLocation);
  
  for (const probLoc of problemLocations) {
    try {
      if (probLoc && probLoc.location && probLoc.target) {
        let problemLocation = new ProblemLocation();
        
        // If updating an existing problem location
        if (probLoc.id) {
          problemLocation = await problemLocationRepository.findOne({
            where: { id: probLoc.id }
          });
          
          if (!problemLocation) {
            problemLocation = new ProblemLocation();
          }
        }
        
        problemLocation.location = probLoc.location;
        problemLocation.target = probLoc.target;
        problemLocation.vulnerability = vulnerability;
        
        const plErrors = await validate(problemLocation);
        if (plErrors.length > 0) {
          console.error('Problem Location validation failed:', plErrors);
          continue;
        }
        
        await problemLocationRepository.save(problemLocation);
      }
    } catch (error) {
      console.error('Error saving problem location:', error);
    }
  }
};

/**
 * @description Save resources to vulnerability
 * @param {Resource[]} resources
 * @param {Vulnerability} vulnerability
 */
export const saveResources = async (resources: Resource[], vulnerability: Vulnerability) => {
  const resourceRepository = AppDataSource.getRepository(Resource);
  
  for (const resource of resources) {
    try {
      if (resource.description && resource.url) {
        let newResource = new Resource();
        
        // If updating an existing resource
        if (resource.id) {
          newResource = await resourceRepository.findOne({
            where: { id: resource.id }
          });
          
          if (!newResource) {
            newResource = new Resource();
          }
        }
        
        newResource.description = resource.description;
        newResource.url = resource.url;
        newResource.vulnerability = vulnerability;
        
        const nrErrors = await validate(newResource);
        if (nrErrors.length > 0) {
          console.error('Resource validation failed:', nrErrors);
          continue;
        }
        
        await resourceRepository.save(newResource);
      }
    } catch (error) {
      console.error('Error saving resource:', error);
    }
  }
};

/**
 * @description Generate JIRA Ticket from Vuln
 * @param {UserRequest} req
 * @param {Response} res
 * @returns JIRA return ID?
 */
export const exportToJira = async (req: UserRequest, res: Response) => {
  try {
    if (!req.params.vulnId) {
      return res.status(400).json('Invalid Vulnerability ID');
    }
    
    if (isNaN(+req.params.vulnId)) {
      return res.status(400).json('Invalid Vulnerability ID');
    }
    
    const vulnerabilityRepository = AppDataSource.getRepository(Vulnerability);
    const assessmentRepository = AppDataSource.getRepository(Assessment);
    const jiraRepository = AppDataSource.getRepository(Jira);
    
    const vuln = await vulnerabilityRepository.findOne({
      where: { id: +req.params.vulnId },
      relations: ['screenshots', 'resources', 'problemLocations', 'assessment']
    });
    
    if (!vuln) {
      return res.status(404).json('Vulnerability not found');
    }
    
    const assessment = await assessmentRepository.findOne({
      where: { id: vuln.assessment.id },
      relations: ['asset']
    });
    
    const hasAccess = await hasAssetWriteAccess(req, assessment.asset.id);
    if (!hasAccess) {
      return res.status(403).json('Authorization is required');
    }
    
    const jira = await jiraRepository.findOne({
      where: { asset: { id: assessment.asset.id } }
    });
    
    if (!assessment.jiraId) {
      return res
        .status(400)
        .json(
          'Unable to create JIRA ticket. Assessment requires an associated Jira ticket.'
        );
    }
    
    if (!jira) {
      return res
        .status(400)
        .json(
          'Unable to create JIRA ticket. Please provide JIRA credentials to the parent Asset.'
        );
    }
    
    const jiraInit: JiraInit = {
      apiKey: jira.apiKey,
      host: jira.host,
      username: jira.username,
    };
    
    try {
      const result = await exportToJiraIssue(vuln, jiraInit);
      vuln.jiraId = `https://${jiraInit.host}/browse/${result.key}`;
      await vulnerabilityRepository.save(vuln);
      return res.status(200).json(`${result.message}`);
    } catch (err) {
      return res.status(404).json(err);
    }
  } catch (error) {
    console.error('Error exporting to Jira:', error);
    return res.status(500).json('An error occurred while exporting to Jira');
  }
};