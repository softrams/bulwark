import { UserRequest } from '../interfaces/user-request.interface';
import { Response } from 'express';
import { getConnection } from 'typeorm';
import { Assessment } from '../entity/Assessment';
import { validate } from 'class-validator';
import { Vulnerability } from '../entity/Vulnerability';
import { File } from '../entity/File';
import { ProblemLocation } from '../entity/ProblemLocation';
import { Resource } from '../entity/Resource';
import { addNewIssue } from '../utilities/jira.utility';
const fileUploadController = require('../routes/file-upload.controller');

/**
 * @description get vulnerability by ID
 * @param {UserRequest} req
 * @param {Response} res contains JSON object with the organization data
 * @returns vulnerability data
 */
export const getVulnById = async (req: UserRequest, res: Response) => {
  if (!req.params.vulnId) {
    return res.status(400).send('Invalid Vulnerability UserRequest');
  }
  if (isNaN(+req.params.vulnId)) {
    return res.status(400).send('Invalid Vulnerability ID');
  }
  // TODO: Utilize createQueryBuilder to only return screenshot IDs and not the full object
  const vuln = await getConnection()
    .getRepository(Vulnerability)
    .findOne(req.params.vulnId, {
      relations: ['screenshots', 'problemLocations', 'resources']
    });
  if (!vuln) {
    return res.status(404).send('Vulnerability does not exist.');
  }
  res.status(200).json(vuln);
};
/**
 * @description Delete vulnerability by ID
 * @param {UserRequest} req vulnID is required
 * @param {Response} res contains JSON object with the success/fail
 * @returns success/error message
 */
export const deleteVulnById = async (req: UserRequest, res: Response) => {
  if (!req.params.vulnId) {
    return res.status(400).send('Invalid vulnerability UserRequest');
  }
  if (isNaN(+req.params.vulnId)) {
    return res.status(400).send('Invalid vulnerability ID');
  }
  const vuln = await getConnection().getRepository(Vulnerability).findOne(req.params.vulnId);
  if (!vuln) {
    return res.status(404).send('Vulnerability does not exist.');
  } else {
    await getConnection().getRepository(Vulnerability).delete(vuln);
    res.status(200).json(`Vulnerability #${vuln.id}: "${vuln.name}" successfully deleted`);
  }
};
/**
 * @description Update vulnerability by ID
 * @param {UserRequest} req
 * @param {Response} res
 * @returns success/error message
 * // TODO: Break apart this function into smaller functions.  Also make common as create is almost the same.
 */
export const patchVulnById = async (req: UserRequest, res: Response) => {
  req = await fileUploadController.uploadFileArray(req, res);
  if (isNaN(+req.body.assessment) || !req.body.assessment) {
    return res.status(400).json('Invalid Assessment ID');
  }
  const assessment = await getConnection().getRepository(Assessment).findOne(req.body.assessment);
  if (!assessment) {
    return res.status(404).json('Assessment does not exist');
  }
  if (isNaN(+req.params.vulnId)) {
    return res.status(400).json('Vulnerability ID is invalid');
  }
  const vulnerability = await getConnection().getRepository(Vulnerability).findOne(req.params.vulnId);
  if (!vulnerability) {
    return res.status(404).json('Vulnerability does not exist');
  }
  const callback = (resStatus: number, message: any) => {
    res.status(resStatus).send(message);
  };
  vulnerability.id = +req.params.vulnId;
  vulnerability.impact = req.body.impact;
  vulnerability.likelihood = req.body.likelihood;
  vulnerability.risk = req.body.risk;
  vulnerability.status = req.body.status;
  vulnerability.description = req.body.description;
  vulnerability.remediation = req.body.remediation;
  vulnerability.jiraId = req.body.jiraId;
  vulnerability.cvssScore = req.body.cvssScore;
  vulnerability.cvssUrl = req.body.cvssUrl;
  vulnerability.detailedInfo = req.body.detailedInfo;
  vulnerability.assessment = assessment;
  vulnerability.name = req.body.name;
  vulnerability.systemic = req.body.systemic;
  const errors = await validate(vulnerability);
  if (errors.length > 0) {
    return res.status(400).send('Vulnerability form validation failed');
  } else {
    await getConnection().getRepository(Vulnerability).save(vulnerability);
    // Remove deleted files
    if (req.body.screenshotsToDelete) {
      const existingScreenshots = await getConnection()
        .getRepository(File)
        .find({ where: { vulnerability: vulnerability.id } });
      const existingScreenshotIds = existingScreenshots.map((screenshot) => screenshot.id);
      let screenshotsToDelete = JSON.parse(req.body.screenshotsToDelete);
      // We only want to remove the files associated to the vulnerability
      screenshotsToDelete = existingScreenshotIds.filter((value) => screenshotsToDelete.includes(value));
      for (const screenshotId of screenshotsToDelete) {
        getConnection().getRepository(File).delete(screenshotId);
      }
    }
    saveScreenshots(req.files, vulnerability, callback);
    // Remove deleted problem locations
    if (req.body.problemLocations.length) {
      const clientProdLocs = JSON.parse(req.body.problemLocations);
      const clientProdLocsIds = clientProdLocs.map((value) => value.id);
      const existingProbLocs = await getConnection()
        .getRepository(ProblemLocation)
        .find({ where: { vulnerability: vulnerability.id } });
      const existingProbLocIds = existingProbLocs.map((probLoc) => probLoc.id);
      const prodLocsToDelete = existingProbLocIds.filter((value) => !clientProdLocsIds.includes(value));
      for (const probLoc of prodLocsToDelete) {
        getConnection().getRepository(ProblemLocation).delete(probLoc);
      }
      saveProblemLocations(clientProdLocs, vulnerability, callback);
    }
    // Remove deleted resources
    if (req.body.resources.length) {
      const clientResources = JSON.parse(req.body.resources);
      const clientResourceIds = clientResources.map((value) => value.id);
      const existingResources = await getConnection()
        .getRepository(Resource)
        .find({ where: { vulnerability: vulnerability.id } });
      const existingResourceIds = existingResources.map((resource) => resource.id);
      const resourcesToDelete = existingResourceIds.filter((value) => !clientResourceIds.includes(value));
      for (const resource of resourcesToDelete) {
        getConnection().getRepository(Resource).delete(resource);
      }
      saveResources(clientResources, vulnerability, callback);
    }
    return res.status(200).json('Vulnerability patched successfully');
  }
};
/**
 * @description Create vulnerability
 * @param {UserRequest} req
 * @param {Response} res
 * @returns success/error message
 */
export const createVuln = async (req: UserRequest, res: Response) => {
  req = await fileUploadController.uploadFileArray(req, res);
  if (isNaN(+req.body.assessment) || !req.body.assessment) {
    return res.status(400).json('Invalid Assessment ID');
  }
  const assessment = await getConnection().getRepository(Assessment).findOne(req.body.assessment);
  if (!assessment) {
    return res.status(404).json('Assessment does not exist');
  }
  const callback = (resStatus: number, message: any) => {
    res.status(resStatus).send(message);
  };
  const vulnerability = new Vulnerability();
  vulnerability.impact = req.body.impact;
  vulnerability.likelihood = req.body.likelihood;
  vulnerability.risk = req.body.risk;
  vulnerability.status = req.body.status;
  vulnerability.description = req.body.description;
  vulnerability.remediation = req.body.remediation;
  vulnerability.jiraId = req.body.jiraId;
  vulnerability.cvssScore = req.body.cvssScore;
  vulnerability.cvssUrl = req.body.cvssUrl;
  vulnerability.detailedInfo = req.body.detailedInfo;
  vulnerability.assessment = assessment;
  vulnerability.name = req.body.name;
  vulnerability.systemic = req.body.systemic;
  const errors = await validate(vulnerability);
  if (errors.length > 0) {
    return res.status(400).send('Vulnerability form validation failed');
  } else {
    await getConnection().getRepository(Vulnerability).save(vulnerability);
    saveScreenshots(req.files, vulnerability, callback);
    const problemLocations = JSON.parse(req.body.problemLocations);
    saveProblemLocations(problemLocations, vulnerability, callback);
    const resources = JSON.parse(req.body.resources);
    saveResources(resources, vulnerability, callback);
    res.status(200).json('Vulnerability saved successfully');
  }
};
/**
 * @description Save screenshots to vulnerability
 * @param {UserRequest} req
 * @param {Response} res
 * @param {Vulnerability} vulnerability
 * @returns saved file or error message
 */
export const saveScreenshots = async (files: File[], vulnerability: Vulnerability, callback) => {
  for (const screenshot of files) {
    let file = new File();
    file = screenshot;
    file.vulnerability = vulnerability;
    const fileErrors = await validate(file);
    if (fileErrors.length > 0) {
      return callback(400, JSON.stringify('File validation failed'));
    } else {
      await getConnection().getRepository(File).save(file);
    }
  }
};
/**
 * @description Save problem locations to vulnerability
 * @param {UserRequest} req
 * @param {Response} res
 * @param {Vulnerability} vulnerability
 * @returns saved problem locations or error message
 */
export const saveProblemLocations = async (
  problemLocations: ProblemLocation[],
  vulnerability: Vulnerability,
  callback
) => {
  for (const probLoc of problemLocations) {
    if (probLoc && probLoc.location && probLoc.target) {
      let problemLocation = new ProblemLocation();
      problemLocation = probLoc;
      problemLocation.vulnerability = vulnerability;
      const plErrors = await validate(problemLocation);
      if (plErrors.length > 0) {
        return callback(400, JSON.stringify('Problem Location validation failed'));
      } else {
        await getConnection().getRepository(ProblemLocation).save(problemLocation);
      }
    } else {
      return callback(400, JSON.stringify('Invalid Problem Location'));
    }
  }
};
/**
 * @description Save resources to vulnerability
 * @param {UserRequest} req
 * @param {Response} res
 * @param {Vulnerability} vulnerability
 * @returns saved resources or error message
 */
export const saveResources = async (resources: Resource[], vulnerability: Vulnerability, callback) => {
  for (const resource of resources) {
    if (resource.description && resource.url) {
      let newResource = new Resource();
      newResource = resource;
      newResource.vulnerability = vulnerability;
      const nrErrors = await validate(newResource);
      if (nrErrors.length > 0) {
        return callback(400, JSON.stringify('Resource Location validation failed'));
      } else {
        await getConnection().getRepository(Resource).save(newResource);
      }
    } else {
      return callback(400, JSON.stringify('Resource Location Invalid'));
    }
  }
};
/**
 * @description Generate JIRA Ticket from Vuln
 * @param {UserRequest} req
 * @param {Response} res
 * @param {Vulnerability} vulnerability
 * @returns JIRA return ID?
 */
export const exportToJira = async (req: UserRequest, res: Response) => {
  if (!req.params.vulnId) {
    return res.status(400).json('Invalid Vulnerability ID');
  }
  if (isNaN(+req.params.vulnId)) {
    return res.status(400).json('Invalid Vulnerability ID');
  }
  const vuln = await getConnection().getRepository(Vulnerability).findOne(req.params.vulnId);
  const assessment = await getConnection().getRepository(Assessment).findOne(vuln.assessment);
  if (!assessment.jiraId) {
    return res.status(400).json('Unable to create JIRA ticket.  Assessment must have an associated JIRA ticket.');
  }
  const result = await addNewIssue(vuln);
  // We will need to save Jira Host, API Key, and user in database and dynamically retrieve by Asset
  vuln.jiraId = `https://${process.env.JIRA_HOST}/browse/`;
  await getConnection().getRepository(Vulnerability).save(vuln);
  return res.status(200).json(`The vulnerability for "${vuln.name}" has been exported to JIRA.  ID: }`);
};
