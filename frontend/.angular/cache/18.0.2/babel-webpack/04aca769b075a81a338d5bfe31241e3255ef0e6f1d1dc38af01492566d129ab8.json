{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Pipe, InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, EventEmitter, Component, Input, Output, SecurityContext, NgModule } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Renderer, marked } from 'marked';\nexport { Renderer as MarkedRenderer } from 'marked';\nimport { map, first } from 'rxjs/operators';\nimport * as i1 from '@angular/common/http';\nimport * as i3 from '@angular/platform-browser';\n\n/* eslint-disable */\nconst _c0 = [\"*\"];\nclass KatexOptions {}\nlet LanguagePipe = /*#__PURE__*/(() => {\n  class LanguagePipe {\n    transform(value, language) {\n      if (value == null) {\n        value = '';\n      }\n      if (language == null) {\n        language = '';\n      }\n      if (typeof value !== 'string') {\n        console.error(`LanguagePipe has been invoked with an invalid value type [${typeof value}]`);\n        return value;\n      }\n      if (typeof language !== 'string') {\n        console.error(`LanguagePipe has been invoked with an invalid parameter [${typeof language}]`);\n        return value;\n      }\n      return '```' + language + '\\n' + value + '\\n```';\n    }\n  }\n  LanguagePipe.ɵfac = function LanguagePipe_Factory(t) {\n    return new (t || LanguagePipe)();\n  };\n  LanguagePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"language\",\n    type: LanguagePipe,\n    pure: true\n  });\n  return LanguagePipe;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar PrismPlugin = /*#__PURE__*/function (PrismPlugin) {\n  PrismPlugin[\"CommandLine\"] = \"command-line\";\n  PrismPlugin[\"LineHighlight\"] = \"line-highlight\";\n  PrismPlugin[\"LineNumbers\"] = \"line-numbers\";\n  return PrismPlugin;\n}(PrismPlugin || {});\nclass MarkedOptions {}\n\n/* eslint-disable max-len */\nconst errorJoyPixelsNotLoaded = '[ngx-markdown] When using the `emoji` attribute you *have to* include Emoji-Toolkit files to `angular.json` or use imports. See README for more information';\nconst errorKatexNotLoaded = '[ngx-markdown] When using the `katex` attribute you *have to* include KaTeX files to `angular.json` or use imports. See README for more information';\nconst errorSrcWithoutHttpClient = '[ngx-markdown] When using the `src` attribute you *have to* pass the `HttpClient` as a parameter of the `forRoot` method. See README for more information';\n/* eslint-enable max-len */\nconst SECURITY_CONTEXT = new InjectionToken('SECURITY_CONTEXT');\nlet MarkdownService = /*#__PURE__*/(() => {\n  class MarkdownService {\n    constructor(platform, securityContext, http, options, sanitizer) {\n      this.platform = platform;\n      this.securityContext = securityContext;\n      this.http = http;\n      this.sanitizer = sanitizer;\n      this.initialMarkedOptions = {\n        renderer: new Renderer()\n      };\n      this.options = options;\n    }\n    get options() {\n      return this._options;\n    }\n    set options(value) {\n      this._options = {\n        ...this.initialMarkedOptions,\n        ...value\n      };\n    }\n    get renderer() {\n      return this.options.renderer;\n    }\n    set renderer(value) {\n      this.options.renderer = value;\n    }\n    compile(markdown, decodeHtml = false, emojify = false, markedOptions = this.options) {\n      const trimmed = this.trimIndentation(markdown);\n      const decoded = decodeHtml ? this.decodeHtml(trimmed) : trimmed;\n      const emojified = emojify ? this.renderEmoji(decoded) : decoded;\n      const compiled = marked(emojified, markedOptions);\n      return this.sanitizer.sanitize(this.securityContext, compiled) || '';\n    }\n    getSource(src) {\n      if (!this.http) {\n        throw new Error(errorSrcWithoutHttpClient);\n      }\n      return this.http.get(src, {\n        responseType: 'text'\n      }).pipe(map(markdown => this.handleExtension(src, markdown)));\n    }\n    highlight(element) {\n      if (!isPlatformBrowser(this.platform)) {\n        return;\n      }\n      if (typeof Prism !== 'undefined') {\n        if (!element) {\n          element = document;\n        }\n        const noLanguageElements = element.querySelectorAll('pre code:not([class*=\"language-\"])');\n        Array.prototype.forEach.call(noLanguageElements, x => x.classList.add('language-none'));\n        Prism.highlightAllUnder(element);\n      }\n    }\n    renderKatex(html, options) {\n      if (!isPlatformBrowser(this.platform)) {\n        return html;\n      }\n      if (typeof katex === 'undefined' || typeof katex.renderToString === 'undefined') {\n        throw new Error(errorKatexNotLoaded);\n      }\n      return html.replace(/\\$([^\\s][^$]*?[^\\s])\\$/gm, (_, tex) => katex.renderToString(tex, options));\n    }\n    decodeHtml(html) {\n      if (!isPlatformBrowser(this.platform)) {\n        return html;\n      }\n      const textarea = document.createElement('textarea');\n      textarea.innerHTML = html;\n      return textarea.value;\n    }\n    handleExtension(src, markdown) {\n      const extension = src ? src.split('?')[0].split('.').splice(-1).join() : '';\n      return extension !== 'md' ? '```' + extension + '\\n' + markdown + '\\n```' : markdown;\n    }\n    renderEmoji(html) {\n      if (!isPlatformBrowser(this.platform)) {\n        return html;\n      }\n      if (typeof joypixels === 'undefined' || typeof joypixels.shortnameToUnicode === 'undefined') {\n        throw new Error(errorJoyPixelsNotLoaded);\n      }\n      return joypixels.shortnameToUnicode(html);\n    }\n    trimIndentation(markdown) {\n      if (!markdown) {\n        return '';\n      }\n      let indentStart;\n      return markdown.split('\\n').map(line => {\n        let lineIdentStart = indentStart;\n        if (line.length > 0) {\n          lineIdentStart = isNaN(lineIdentStart) ? line.search(/\\S|$/) : Math.min(line.search(/\\S|$/), lineIdentStart);\n        }\n        if (isNaN(indentStart)) {\n          indentStart = lineIdentStart;\n        }\n        return lineIdentStart ? line.substring(lineIdentStart) : line;\n      }).join('\\n');\n    }\n  }\n  MarkdownService.ɵfac = function MarkdownService_Factory(t) {\n    return new (t || MarkdownService)(i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(SECURITY_CONTEXT), i0.ɵɵinject(i1.HttpClient, 8), i0.ɵɵinject(MarkedOptions, 8), i0.ɵɵinject(i3.DomSanitizer));\n  };\n  MarkdownService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MarkdownService,\n    factory: MarkdownService.ɵfac\n  });\n  return MarkdownService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MarkdownComponent = /*#__PURE__*/(() => {\n  class MarkdownComponent {\n    constructor(element, markdownService) {\n      this.element = element;\n      this.markdownService = markdownService;\n      // Event emitters\n      this.error = new EventEmitter();\n      this.load = new EventEmitter();\n      this.ready = new EventEmitter();\n      this._commandLine = false;\n      this._emoji = false;\n      this._katex = false;\n      this._lineHighlight = false;\n      this._lineNumbers = false;\n    }\n    // Plugin - emoji\n    get emoji() {\n      return this._emoji;\n    }\n    set emoji(value) {\n      this._emoji = this.coerceBooleanProperty(value);\n    }\n    // Plugin - katex\n    get katex() {\n      return this._katex;\n    }\n    set katex(value) {\n      this._katex = this.coerceBooleanProperty(value);\n    }\n    // Plugin - lineHighlight\n    get lineHighlight() {\n      return this._lineHighlight;\n    }\n    set lineHighlight(value) {\n      this._lineHighlight = this.coerceBooleanProperty(value);\n    }\n    // Plugin - lineNumbers\n    get lineNumbers() {\n      return this._lineNumbers;\n    }\n    set lineNumbers(value) {\n      this._lineNumbers = this.coerceBooleanProperty(value);\n    }\n    // Plugin - commandLine\n    get commandLine() {\n      return this._commandLine;\n    }\n    set commandLine(value) {\n      this._commandLine = this.coerceBooleanProperty(value);\n    }\n    ngOnChanges() {\n      if (this.data != null) {\n        this.handleData();\n        return;\n      }\n      if (this.src != null) {\n        this.handleSrc();\n        return;\n      }\n    }\n    ngAfterViewInit() {\n      if (!this.data && !this.src) {\n        this.handleTransclusion();\n      }\n    }\n    render(markdown, decodeHtml = false) {\n      let compiled = this.markdownService.compile(markdown, decodeHtml, this.emoji);\n      compiled = this.katex ? this.markdownService.renderKatex(compiled, this.katexOptions) : compiled;\n      this.element.nativeElement.innerHTML = compiled;\n      this.handlePlugins();\n      this.markdownService.highlight(this.element.nativeElement);\n      this.ready.emit();\n    }\n    coerceBooleanProperty(value) {\n      return value != null && `${String(value)}` !== 'false';\n    }\n    handleData() {\n      this.render(this.data);\n    }\n    handleSrc() {\n      this.markdownService.getSource(this.src).subscribe(markdown => {\n        this.render(markdown);\n        this.load.emit(markdown);\n      }, error => this.error.emit(error));\n    }\n    handleTransclusion() {\n      this.render(this.element.nativeElement.innerHTML, true);\n    }\n    handlePlugins() {\n      if (this.commandLine) {\n        this.setPluginClass(this.element.nativeElement, PrismPlugin.CommandLine);\n        this.setPluginOptions(this.element.nativeElement, {\n          dataFilterOutput: this.filterOutput,\n          dataHost: this.host,\n          dataPrompt: this.prompt,\n          dataOutput: this.output,\n          dataUser: this.user\n        });\n      }\n      if (this.lineHighlight) {\n        this.setPluginOptions(this.element.nativeElement, {\n          dataLine: this.line,\n          dataLineOffset: this.lineOffset\n        });\n      }\n      if (this.lineNumbers) {\n        this.setPluginClass(this.element.nativeElement, PrismPlugin.LineNumbers);\n        this.setPluginOptions(this.element.nativeElement, {\n          dataStart: this.start\n        });\n      }\n    }\n    setPluginClass(element, plugin) {\n      const preElements = element.querySelectorAll('pre');\n      for (let i = 0; i < preElements.length; i++) {\n        const classes = plugin instanceof Array ? plugin : [plugin];\n        preElements.item(i).classList.add(...classes);\n      }\n    }\n    setPluginOptions(element, options) {\n      const preElements = element.querySelectorAll('pre');\n      for (let i = 0; i < preElements.length; i++) {\n        Object.keys(options).forEach(option => {\n          const attributeValue = options[option];\n          if (attributeValue) {\n            const attributeName = this.toLispCase(option);\n            preElements.item(i).setAttribute(attributeName, attributeValue.toString());\n          }\n        });\n      }\n    }\n    toLispCase(value) {\n      const upperChars = value.match(/([A-Z])/g);\n      if (!upperChars) {\n        return value;\n      }\n      let str = value.toString();\n      for (let i = 0, n = upperChars.length; i < n; i++) {\n        str = str.replace(new RegExp(upperChars[i]), '-' + upperChars[i].toLowerCase());\n      }\n      if (str.slice(0, 1) === '-') {\n        str = str.slice(1);\n      }\n      return str;\n    }\n  }\n  MarkdownComponent.ɵfac = function MarkdownComponent_Factory(t) {\n    return new (t || MarkdownComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(MarkdownService));\n  };\n  MarkdownComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MarkdownComponent,\n    selectors: [[\"markdown\"], [\"\", \"markdown\", \"\"]],\n    inputs: {\n      data: \"data\",\n      src: \"src\",\n      emoji: \"emoji\",\n      katex: \"katex\",\n      katexOptions: \"katexOptions\",\n      lineHighlight: \"lineHighlight\",\n      line: \"line\",\n      lineOffset: \"lineOffset\",\n      lineNumbers: \"lineNumbers\",\n      start: \"start\",\n      commandLine: \"commandLine\",\n      filterOutput: \"filterOutput\",\n      host: \"host\",\n      prompt: \"prompt\",\n      output: \"output\",\n      user: \"user\"\n    },\n    outputs: {\n      error: \"error\",\n      load: \"load\",\n      ready: \"ready\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function MarkdownComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return MarkdownComponent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MarkdownPipe = /*#__PURE__*/(() => {\n  class MarkdownPipe {\n    constructor(domSanitizer, elementRef, markdownService, zone) {\n      this.domSanitizer = domSanitizer;\n      this.elementRef = elementRef;\n      this.markdownService = markdownService;\n      this.zone = zone;\n    }\n    transform(value) {\n      if (value == null) {\n        return '';\n      }\n      if (typeof value !== 'string') {\n        console.error(`MarkdownPipe has been invoked with an invalid value type [${typeof value}]`);\n        return value;\n      }\n      const markdown = this.markdownService.compile(value);\n      this.zone.onStable.pipe(first()).subscribe(() => this.markdownService.highlight(this.elementRef.nativeElement));\n      return this.domSanitizer.bypassSecurityTrustHtml(markdown);\n    }\n  }\n  MarkdownPipe.ɵfac = function MarkdownPipe_Factory(t) {\n    return new (t || MarkdownPipe)(i0.ɵɵdirectiveInject(i3.DomSanitizer, 16), i0.ɵɵdirectiveInject(i0.ElementRef, 16), i0.ɵɵdirectiveInject(MarkdownService, 16), i0.ɵɵdirectiveInject(i0.NgZone, 16));\n  };\n  MarkdownPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"markdown\",\n    type: MarkdownPipe,\n    pure: true\n  });\n  return MarkdownPipe;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst sharedDeclarations = [LanguagePipe, MarkdownComponent, MarkdownPipe];\nlet MarkdownModule = /*#__PURE__*/(() => {\n  class MarkdownModule {\n    static forRoot(markdownModuleConfig) {\n      return {\n        ngModule: MarkdownModule,\n        providers: [MarkdownService, markdownModuleConfig && markdownModuleConfig.loader || [], markdownModuleConfig && markdownModuleConfig.markedOptions || [], {\n          provide: SECURITY_CONTEXT,\n          useValue: markdownModuleConfig && markdownModuleConfig.sanitize != null ? markdownModuleConfig.sanitize : SecurityContext.HTML\n        }]\n      };\n    }\n    static forChild() {\n      return {\n        ngModule: MarkdownModule\n      };\n    }\n  }\n  MarkdownModule.ɵfac = function MarkdownModule_Factory(t) {\n    return new (t || MarkdownModule)();\n  };\n  MarkdownModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MarkdownModule\n  });\n  MarkdownModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return MarkdownModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { KatexOptions, LanguagePipe, MarkdownComponent, MarkdownModule, MarkdownPipe, MarkdownService, MarkedOptions, PrismPlugin, SECURITY_CONTEXT, errorJoyPixelsNotLoaded, errorKatexNotLoaded, errorSrcWithoutHttpClient };\n//# sourceMappingURL=ngx-markdown.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}